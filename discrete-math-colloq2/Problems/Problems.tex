\documentclass[a4paper,12pt]{article}

\usepackage{header}
\usepackage{dsfont}

\newcommand {\gu} [1] {\guillemotleft#1\guillemotright}
\renewcommand{\Pr} {\text {Pr}}
\newcommand{\tab}{\quad\=}
\newenvironment{programm}{
    \ttfamily
    \begin{tabbing}
    }
    {
    \end{tabbing}
}


\begin{document}
	\title{Дискретная математика. Коллоквиум весна 2017. \\ Задачи}
	\author{Ваномас}
	\maketitle
	
	\section*{Задача 4}
	О событиях $A$ и $B$ вероятностного пространства $U$ известно, что $\Pr [A]$ = $\Pr [B] = 4/5$. Могут ли при этом события $A\cup B$ и $B$ быть независимыми?
	
	\subsection*{Решение}
	Пусть вероятностное пространство $U$ задано таким образом, что любой исход на нём --- число от $0$ до $4$, событие $A$: \gu{число не равно 0} и $B$: \gu{число не равно 1}. Очевидно, что вероятность каждого из этих событий в отдельности равна $4/5$. Событию $A\cup B$: \gu{число не равно 0 \textit{или} число не равно 1} удовлетворяют все исходы. Таким образом, выполнено равенство $\Pr [A\cup B]\cdot\Pr [B]=1\cdot\Pr [B] = \Pr[B]$, то есть события $A\cup B$ и $B$ являются независимыми.
	
	\sep
	\section*{Задача 18}
	Постройте вычислимую биекцию между множествами $\N$ и $\N\,\backslash\,\{p^2\,|\,p\in\N\}$.
	\subsection*{Решение}
	Сначала определим разрешающую функцию второго множества $f(n)$:
    \begin{programm}
    \tab i = 0\\
    \tab while (i * i ) < n\\
    \tab\tab i = i + 1\\
    \tab return (i * i == n)
    \end{programm}
    Теперь рассмотрим отображение $g(x): \N\to\N\,\backslash\,\{p^2\,|\,p\in\N\}$, заданное следующим образом:
	
    \begin{programm}
    \tab i = 0\\
    \tab j = 0\\
    \tab while (i != n)\\
    \tab\tab while (f(j))\\
    \tab\tab\tab j = j + 1\\
    \tab\tab i = i + 1\\
    \tab return j
    \end{programm}
	
	Данное отображение сопоставляет числу $x$ элемент множества $\N\,\backslash\,\{p^2\,|\,p\in\N\}$, имеющий номер $x$ с начала в порядке возрастания (элементы $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ могут быть перечислены в порядке возрастания, так как оно разрешимо). Оно инъективно, так как элементы с различными номерами не равны (два различных элементы множества не равны). Также оно сюръективно, поскольку любой элемент $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ имеет некоторый номер, и для элемента из этого множества с номером $n$ прообразом будет число $n$. Таким образом, отображение $g$ биективно.
	\sep	
	
	\begin{comment}
	\section*{Задача 18}
    Постройте вычислимую биекцию между множествами $\N$ и $\N\,\backslash\,\{p^2\,|\,p\in\N\}$.
	\subsection*{Решение}
    Поскольку множество $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ разрешимо, его элементы могут быть перечислены в порядке возрастания (для этого перечисляющему алгоритму нужно последовательно идти по натуральным числам, начиная с 0, и, если текущее число входит в $\N\,\backslash\,\{p^2\,|\,p\in\N\}$, выводить его). Следовательно, элементы $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ могут быть пронумерованы натуральными числами. Тогда можно задать следующее отображение $f: \N\to\N\,\backslash\,\{p^2\,|\,p\in\N\}$: элементу $x\in\N$ сопоставляется элемент $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ с номером $n$. Это отображение инъективно, так как элементы с различными номерами не равны (два различных элементы множества не равны). Также оно сюръективно, поскольку любой элемент $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ имеет некоторый номер, и для элемента из этого множества с номером $n$ прообразом будет число $n$. Таким образом, отображение $g$ биективно.
    
	\sep
	
    \end{comment}
	
	\section*{Задача 19}
	Постройте вычислимую биекцию между множеством двоичных слов и натуральными числами.
	\subsection*{Решение}
	Выпишем в столбец все двоичные слова длины $1$, затем в ещё один столбец --- двоичные слова длины $2$, затем --- слова длины $3$, и так далее. Пронумеруем последовательно, начиная с $0$, сначала слова в первом столбце, затем, продолжая нумерацию, во втором, затем --- в третьем, и так далее. Нумерация будет выглядеть следующим образом: \\\\
	{
	\boldmath
	\begin{tabular}{c c c c c}
	   0 : $0$  & 2 : $00$ & \phantom{1}6 : $000$ & 14 : $0000$ & \ldots\ldots\ldots\\
	   1 : $1$  & 3 : $01$ & \phantom{1}7 : $001$ & 15 : $0001$ & \ldots\ldots\ldots\\
	            & 4 : $10$ & \phantom{1}8 : $010$ & 16 : $0010$ & \ldots\ldots\ldots\\
	            & 5 : $11$ & \phantom{1}9 : $011$ & 17 : $0011$ & \ldots\ldots\ldots\\
	            &          & 10 : $100$           & 18 : $0100$ & \ldots\ldots\ldots\\
	            &          & 11 : $101$           & 19 : $0101$ & \ldots\ldots\ldots\\
	            &          & 12 : $110$           & 20 : $0110$ & \ldots\ldots\ldots\\
                &          & 13 : $111$           & 21 : $0111$ & \ldots\ldots\ldots\\
	            &          &                      & 22 : $1000$ & \ldots\ldots\ldots\\
	            &          &                      & 23 : $1001$ & \ldots\ldots\ldots\\
	            &          &                      & 24 : $1010$ & \ldots\ldots\ldots\\
	            &          &                      & 25 : $1011$ & \ldots\ldots\ldots\\
	            &          &                      & 26 : $1100$ & \ldots\ldots\ldots\\
	            &          &                      & 27 : $1101$ & \ldots\ldots\ldots\\
	            &          &                      & 28 : $1110$ & \ldots\ldots\ldots\\
	            &          &                      & 29 : $1111$ & \ldots\ldots\ldots\\
	      
	   \end{tabular}
	}
	\\\\
	Посроим отображение, которое ставит в соответствие натуральному числу $n$ двоичное слово, имеющее номер $n$ в данной нумерации. Заметим, что это отображение инъективно --- слова с различными номерами различны, так как слова в одном столбце различны по построению, а слова в различных столбцах имеют разную длину. Также оно сюръективно, поскольку каждому номеру соответствует некоторое двоичное слово, так как их бесконечно много, и они были пронумерованы последовательно (если какому-то номеру не соответствует двоичное слово, значит, либо пронумеровано конечное количество слов, либо какой-то номер был \gu{пропущен}). Таким образом, построенное отображение биективно.

	\sep	
		
		
	\section*{Задача 20}
	Пусть $f$ --- вычислимая биекция между $\N$ и $\N$. Докажите, что обратная биекция $f^{-1}$ также вычислима.

	
	\subsection*{Решение}
	Функция $f(x):\N\to\N$ --- вычислимое биективное отображение. Рассмотрим следующий алгоритм, принимающий на вход $x$:
	\begin{programm}
	\tab i = 0\\
	\tab while (f(i) != x)\\
	\tab\tab i = i + 1\\
	\tab return i
	\end{programm}
    Этот алгоритм, очевидно, на входе $x$ вернёт значение $i$, на котором $f$ принимает значение $x$, то есть $f^{-1}(x)$. Также цикл {\ttfamily while} совершит ровно $i$ итераций, то есть конечное число, поскольку прообраз $x$ конечен. Таким образом, алгоритм остановится на любом входе за конечное число шагов, то есть соответствующая ему функция $f^{-1}$ вычислима.

	\sep		
	
	
	
	
	\section*{Задача 21}
    Докажите, что, если функция $f$ вычислима и $A \subset \N$ --- перечислимое множество, то и образ, и прообраз множетсва $A$ перечислимы.
	
	\subsection*{Решение}
	
    Докажем, что декартово произведение перечислимых множеств также перечислимо. Пусть множества $A$ и $B$ перечислимы, то есть для них существуют алгоритмы, с помощью которых могут быть получены все их элементы. Из этого следует, что элементы этих множеств могут быть пронумерованы в порядке, в котором они выводятся вышеназванными алгоритмами. Тогда для них существуют функции $f(x)$ и $b(x)$, сопоставляющие натуральному числу $x$ элементы $A$ и $B$ соответственно, имеющие в вышеобозначенной нумерации номер $x$ (если множество конечно, то для $x$, больших числа элементов в этом множестве, соответствующая функция не определена).  Предположим, что оба множества бесконечны. Тогда рассмотрим следующий алгоритм, принимающий на вход натуральное число $x$:
    \begin{programm}
    \tab a\_index = 0\\
    \tab b\_index = 0\\
    \tab number = 0\\
    \tab while (number != x)\\
    \tab \tab if (a\_index > 0)\\
    \tab \tab \tab a\_index = a\_index - 1\\
    \tab \tab \tab b\_index = b\_index + 1\\
    \tab \tab else\\
    \tab \tab \tab a\_index = b\_index + 1\\
    \tab \tab \tab b\_index = 0\\
    \tab \tab numder = number + 1\\
    \tab return (a[a\_index], b[b\_index])\\
    \end{programm}
	
	
	Докажем по индукции по $(i+j)$, что комбинация элементов ($a[i], b[j]$) будет выведена на входе $\frac{(i+j)(i+j+1)}2+j$. Заметим, что на входе $x$ цикл \texttt{while} совершает ровно $x$ итераций. База индукции --- $(i+j)=0$. Такому условию удовлетворяет только комбинация $(a[0], b[0])$, и несложно проверить, что она действительно будет выведена на входе $0$. Пусть теперь утверждение верно для всех комбинаций, для которых $(i+j)=k$. Докажем это для комбинаций, для которых $(i+j)=k+1$. По предположению индукции на входе $\frac{k(k+1)}2+k$ будет выведена комбинация $(a[0], b[k])$, то есть через $\frac{k(k+1)}2+k$ итерацию значениея \texttt{a\_index} и \texttt{b\_index} будут соответственно равны $0$ и $k$. Тогда на следующей итерации значения станут равны соответственно $k+1$ и $0$. Как мы знаем, цикл остановится на следующей итерации на входе $\frac{k(k+1)}2+k+1$, то есть $\frac{(k+1)(k+2)}2+0$. На следующем $k+1$ входе финальное значение \texttt{a\_index} будет каждый раз на $1$ уменьшатья, а \texttt{b\_index} --- увеличиваться, то есть на входе $\frac{(k+1)(k+2)}2+j$ будет выведена комбинация $(a[k+1-j], b[j])$ (при $j\geqslant k+1$, что и требовалось доказать.\\\\
	Теперь рассмотрим случай, в котором хотя бы одно из множеств конечно. Без ограничения общности предположим, что это множество $A$. Пусть количество его элементов равно $A\_size$. Тогда алгоритм, получающий все его элементы, совершает при этом конечное число шагов (так как для получения одного элемента он должен совершать конечное число шагов --- иначе этот элемент никогда не будет получен). В таком случае рассмотрим следующий алгоритм, принимающий на вход натуральное число $x$:
	\begin{programm}
    \tab a\_index = 0\\
    \tab b\_index = 0\\
    \tab number = 0\\
    \tab while (number != x)\\
    \tab \tab if (a\_index < A\_size)\\
    \tab \tab \tab a\_index = a\_index + 1\\
    \tab \tab else\\
    \tab \tab \tab a\_index = 0\\
    \tab \tab \tab b\_index = b\_index + 1\\
    \tab \tab number = number + 1\\
    \tab return (a[a\_index], b[b\_index])\\
	\end{programm}
	
	Этот алгоритм выведет комбинацию $(a[i], b[j])$ на входе $j\cdot A\_size + i$ (в предположении, что $i\leqslant A\_size$) Это несложно доказать: заметим, что каждые $A\_size$ итераций цикла \texttt{while} значение \texttt{a\_index} обнуляется, а \texttt{b\_index} увеличивается на $1$, в остальных же итерациях \texttt{a\_index} увеличивается на $1$, то есть финальное значение \texttt{a\_index} равно остатку при делении количества выполненных итераций на $A\_size$, а значение \texttt{b\_index} --- целой части при делении на $A\_size$. Количество же итераций, по аналогии с предыдущим описанным алгоритмом, равно входному значению. Заметим также, что бесконечность множества $B$ нигде не использовалась: если оно конечно, то вышеописанный алгоритм никогда не остановится на входах $j\cdot A\_size + i$, где $j > B\_size$, поскольку во время его работы будет вызвана невычислимая функция $b[j]$.\\\\
	Таким образом, выше было показано, что декартово произведение двух перечислимых множеств перечислимо. Докажем теперь, что, если функция $f$ вычислима и $A \subset \N$ --- перечислимое множество, то прообраз $A$ перечислим. Поскольку $A$ перечислимо, то и $A \times \N$ также перечислимо. Тогда существует алгоритм $\mathfrak{A}$, получающий все элементы этого множества. Рассмотрим алгоритм, который запускает $\mathfrak{A}$, и, получая некоторый элемент $(x, y)$, проверяет, является ли $x$ образом $y$ при отображении $f$, и, если это так, выводит $y$. Поскольку $x$ --- элемент $A$, то, что $x$ является образом $y$, означает, что $y$ входит в прообраз $A$, то есть вышеописанный алгоритм выводит только элементы $f^{-1}(A)$. Докажем, что он выведет все элементы $f^{-1}(A)$: если $m$ входит в $f^{-1}(A)$, существует $n$ такой, что $n\in A$ и $f(m)=n$. Поскольку $\mathfrak{A}$ получает все пары $(x, y)$, где $x \in A$ и $y \in \N$, за конечное число шагов, а функция $f$ вычислима (то есть алгоритм завершит \gu{обработку} любой полученной $\mathfrak{A}$ пары за конечное число шагов), пара $n, m$ также будет получена, а, поскольку $f(m)=n$, число $m$ будет выведено.\\\\
	Теперь докажем, что, если функция $f$ вычислима и $A \subset \N$ --- перечислимое множество, то образ $A$ также перечислимое множество. Поскольку $A$ перечислимо, существует некий алгоритм $\mathfrak{T}$, получающий все элементы $A$. Рассмотрим алгоритм, который запускает $\mathfrak{T}$ и, получая элемент $x$, выводит $f(x)$. Этот алгоритм, очевидно, выводит только элементы из $f(A)$. Также любой элемент $f(A)$ будет выведен через конечное число шагов, так как для любого $a\in f(A)$ существует $x\in A$ такое, что $a=f(x)$, $\mathfrak{T}$ получает любой элемент $A$ за конечное число шагов, а $f$ вычислима.
	
	\sep
	
	\section*{Задача 22}
	Найдите разрешимое множество $A$ и вычислимую функцию $f$ такие, что прообраз $f^{-1}(A)$ неразрешим.
	\subsection*{Решение}
	Пусть $K$ --- некоторое перечислимое, но неразрешимое множество, $k(x)$ --- функция, возвращающая $x$-ый по счёту вывод перечисляющего алгоритма $\mathfrak{A}$ для множества $K$. Тогда рассмотрим следующий алгоритм, принимающий на вход натуральное число $x$:
	\begin{programm}
	\tab i = 0\\
	\tab while (true)\\
	\tab \tab if (k(i) == x)\\
	\tab \tab \tab return 1\\
	\tab \tab i = i + 1\\
	\end{programm}
	
	Данный алгоритм, по сути, запускает внутри себя $\mathfrak{A}$, последовательно для каждого вывода $\mathfrak{A}$ проверяет, не равен ли данный вывод $x$, и в случае положительного ответа останавливается, выводя \gu{1} как результат своей работы. Поскольку для любого $k\in K$ алгоритм $\mathfrak{A}$ выводит $k$ через конечное число шагов, на входе $k$ вышеописанный алгоритм завершиться через конечное число шагов. На любом входе $p\not\in K$ алгоритм никогда не завершится, поскольку $p$ не является результатом работы $\mathfrak{A}$, и, следовательно, не принадлежит множеству значений $k(x)$. Функция $f$, вычисляемая приведённым выше алгоритмом, возвращает $1$ на элементах $K$ и не определена на $\N\,\backslash\,K$. Таким образом, $f^{-1}(\{1\})=K$, то есть $f$ и $\{1\}$ являются соответственно искомой функцией и искомым множеством.

	
\end{document}
